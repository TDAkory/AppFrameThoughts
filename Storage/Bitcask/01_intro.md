# Bitcask

A Log-Structured Hash Table for Fast Key/Value Data

-[Bitcask - A Log-Structured Hash Table](https://tech-lessons.in/en/blog/bitcask/)
-[Bitcask设计原理及具体实现](https://www.cnblogs.com/wan-ming-zhu/p/18152775)

应用场景：

- 读写低延迟
- 高吞吐，特别是对大量的随机写入
- 能够处理超过内存容量的数据
- 崩溃恢复友好，能够保证快速恢复，尽量不丢数据
- 简单的备份和恢复策略
- value的大小远大于key，但是value不能太大

## 基本

### 文件结构

Bitcask是一种基于文件系统的存储结构，具有独特的文件组织和数据存储格式。

1. **整体目录结构**：一个Bitcask实例对应一个目录，同一时刻仅允许一个进程操作该目录，此进程可视为数据库服务器。目录中包含一个活跃文件和多个旧数据文件。
2. **活跃文件与旧数据文件**
    - **活跃文件**：同一时刻只有一个活跃文件用于服务器写入。当活跃文件大小达到指定阈值时，会被关闭，同时创建新的活跃文件。
    - **旧数据文件**：文件因写满或服务器（进程）退出而关闭后，就成为旧数据文件。旧数据文件不可变，不再进行写操作。
3. **数据存储格式**：写入磁盘文件的数据有固定格式，包含以下字段：

### 文件格式

| 字段       | 大小       | 描述                                   |
|-----------|----------|----------------------------------------|
| crc       | 固定大小   | CRC校验码，用于错误检测                     |
| tstamp    | 32-bit int | 内部使用的32位整数时间戳（不对外暴露）       |
| ksz      | 固定大小   | 键（key）的大小                             |
| value_sz | 固定大小   | 值（value）的大小                         |
| key      | 可变大小   | 实际的键数据                             |
| value    | 可变大小   | 实际的值数据                             |

### 索引

在内存中维护了全部数据的索引（keydir）。索引结构在原文章介绍中使用一个哈希表来存储。主要有这些字段：

| 字段       | 描述                           |
|------------|--------------------------------|
| Key       | 指向记录的键值对的唯一标识符       |
| file_id   | 存储数据的文件标识符               |
| value_sz  | 值的大小，即值所占用的字节数         |
| value_pos | value 所在的整条记录据起始位置的偏移量（record_pos更合适），后续检索时会用到         |
| tstamp    | 记录的时间戳，用于标识记录的时间信息   |

### 写入

追加写文件 + 内存建索引

读取过程如图：

![bitcask read](https://raw.githubusercontent.com/TDAkory/ImageResources/master/img/AppFrameThoughts/bitcask_read.jpg)

### 删除

追加写入tombstone，标记删除 + 更新内存索引

### 压实（Compact）

经过 merge 之后，新创建的数据文件里面保存的都是有效的最新记录，这里的 merge data file 还表示旧的数据文件，只不过是 merge 之后的。然后我们看到 merge 之后，它还会为每个数据文件生成一个 hint 文件，hint 文件里面保存的是记录的一些元信息，比如在数据文件中的位置、value 的大小。

Bitcask 进程重新启动时要在内存中构建 keydir，如果是基于数据文件构建的话会很慢，而通过 hint 文件就可以快速构建了。因为 hint 文件里面不保存实际数据，它的容量会远比数据文件要小。所以到这里我们可以看出，Bitcask 是纯内存索引，在查找 value 时必须经过内存中的 keydir。因此有人发现了，这不就是将 key 放在内存中，将 value 放在了磁盘中吗？

是的，Bitcask 将 key 和 value 分开存储了。

hintfile的记录：

| 字段名称    | 大小       | 描述                                   |
|------------|----------|----------------------------------------|
| tstamp     | 32-bit int  | 内部使用的32位整数时间戳（不对外暴露）       |
| ksz       | 固定大小   | 键（key）的大小                             |
| value_sz  | 固定大小   | 值（value）的大小                           |
| value_pos | 固定大小   | record pos                               |
| key       | 可变大小   | 实际的键数据                               |

## 存储容量

哈希表的结构：key -> |file_id| record size | record offset | timestamp |
假设是 4+4+4+4 个字节（假设 offset 用 4 个字节表示，日志文件寻址范围在 0-4G 之间）
假设key的平均大小为 32 字节
一个 key/value 在内存中最少占用 32+16 字节，那么32G内存可以存储 32G/(32+16)B = 715,827,882 个索引。

日志结构：|crc|tstamp|key_sz|value_sz|key|value|
假设前面头部元数据用 4+4+4+4 个字节。
假设用户key的平均大小为32B, value平均大小是8KB
磁盘的总空间占用是 ( 715,827,882 * (8 * 1024 +32+16)) / ( 1024 * 1024 * 1024 * 1024 ) = 5.36 TB

若要写满16TB的磁盘，需要内存：( 16 TB / (16+32+8KB) ) * 48B = 95.44 GB 