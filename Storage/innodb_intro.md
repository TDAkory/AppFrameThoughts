# [InnoDB](https://en.wikipedia.org/wiki/InnoDB#:~:text=InnoDB%20is%20a%20storage%20engine,the%20release%20of%20MySQL%205.5.)

![InnoDB表空间由 段、区、页 组成](https://raw.githubusercontent.com/TDAkory/ImageResources/master/img/AppFrameThoughts/innodb_logic.png)

最小数据单元式Row，读写磁盘的最小单位是Page

单个Page设计成固定大小：

1. **高效利用磁盘IO性能**：因每次磁盘IO有最小读取单元，将Page设计成最小磁盘单位的整数倍，能高效利用磁盘IO性能。
2. **简化数据读写**：innodb采用原地更新的磁盘数据更新方式，固定大小的Page结构可大大简化数据的读取和写入，无需考虑空洞和空间不足问题。
3. **节省元数据开销**：固定大小的Page可节省记录page size的元数据开销，如bcache2的可变长page engine虽能更高效利用空间，但Page index需记录page size这一元信息 。 

**区的设置原因及大小**：InnoDB将64个连续页划分为一个区，每个区大小为1MB。以页为单位分配存储空间会导致大量随机I/O，磁盘查询慢，按区分配能让相邻页物理位置相邻，用顺序I/O代替随机I/O，在范围查询时更高效，数据量大时还可一次性分配多个连续区。

**段的设置原因及组成**：B+树叶子节点和非叶子节点功能不同，混合存储会产生大量随机I/O。InnoDB提出段的概念，常见的段有数据段、索引段、回滚段等。段是逻辑概念，由若干完整区组成（含碎片页），不同段不能使用同一个区 。 

![innodb_data_page](https://raw.githubusercontent.com/TDAkory/ImageResources/master/img/AppFrameThoughts/innodb_data_page.png)

1. **行记录的存储**：每一行记录都有next_record记录，用于记录下一条记录的偏移量，records间无需有序，通过next_record串联的链表有序即可。
2. **Page Dictory结构**：Page结构中有Page Dictory，它将页中的记录分组，槽存放每组最大记录的相对位置，组的记录数通过最大记录头中的n_owned表示。
3. **分组记录数规则**：Infimum记录所在分组只能有1条记录，Supremum记录所在分组记录条数在1 - 8条之间，其他分组记录数在4 - 8条之间。
4. **InnoDB定位记录方式**：利用二分查找确定记录所在槽，找到槽所在分组主键值最小的记录，通过其next_record遍历记录，快速定位匹配记录，思路与跳表相似。 
5. **参考链接**：https://juejin.cn/post/6974225353371975693 提供所有字段详细讲解。 

## 线程模型

1. **主线程(Master Thread)**：负责协调和调度其他线程，处理关键后台任务，如缓冲池的刷新、脏页的写入等。

2. **IO线程(IO Threads)**：
   - **读线程(Read Threads)**：负责处理异步读取请求，可通过参数`innodb_read_io_threads`配置数量，默认4个。
   - **写线程(Write Threads)**：负责处理异步写入请求，可通过参数`innodb_write_io_threads`配置数量，默认4个。

3. **日志线程(Log Thread)**：专门处理日志写入操作，将日志缓冲区的内容写入到磁盘日志文件中。

4. **清除线程(Purge Thread)**：负责回收已经删除的记录所占用的空间，执行事务提交后的清除操作。

5. **刷新线程(Flush Thread)**：负责将缓冲池中的脏页刷新到磁盘，可通过参数`innodb_flush_log_at_trx_commit`控制刷新策略。

6. **锁监控线程(Lock Monitor)**：监控数据库中的锁状态，检测死锁并进行处理。

## 事务

- 【持久性】通过 redo log （重做日志）来保证的
- 【原子性】通过 undo log（回滚日志） 来保证的
- 【隔离性】通过 MVCC（多版本并发控制+读写锁）来保证的
- 【一致性】则是通过持久性+原子性+隔离性来保证

### Redo Log

1. **数据修改步骤**：先在缓存页哈希表查找缓存页，未加载则从磁盘加载到空闲缓存页；在缓存页执行增删改，脏页加入 Flush 链表；后台线程在时机合适时刷盘。
2. **直接下刷脏页的问题**：每次更新事务完成后直接下刷脏页，可能只修改部分数据却下刷整个 16KB 页面，性能差。
3. **WAL 机制**：内存中有 log buffer 暂存数据修改，有单独 log file 持久化其数据，可聚合修改提高性能，且顺序写入比随机写性能好。
4. **Redo Log 本质**：记录对表空间数据页偏移量处修改的字节值，需记录表空间号等信息，占用空间小，一条日志几个字节到几十个字节。 

### Undo Log

1. **undo log保障事务原子性**：事务的原子性要求增删改操作要么都成功，要么都不做。对数据库修改前先记录undo log，事务失败或回滚时，用其将数据回滚到修改前状态。
2. **innodb行记录的隐藏列**：innodb的行记录中有三个隐藏列，分别是DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR。
3. **DB_ROW_ID**：若表未显式定义主键且无唯一索引，InnoDB会自动添加row_id隐藏列作为主键。
4. **DB_TRX_ID**：事务对记录做增删改时，会将事务ID写入trx_id中。
5. **DB_ROLL_PTR**：作为回滚指针，本质上指向undo log list，维护历史版本数据链，为mvcc快照读做准备 。 

## 锁

InnoDB 存储引擎提供了多种锁类型，每种锁类型都有其特定的使用场景和规则。以下是 InnoDB 锁的种类和加锁规则的详细介绍：

1. **全局锁** ：对整个数据库实例加锁，使数据库处于只读状态。使用 `FLUSH TABLES WITH READ LOCK` 命令加全局锁`UNLOCK TABLES` 命令释放锁。其典型使用场景是做全库的逻辑备份，但会导致所有写操作被阻塞，长时间锁定可能引起业务停和主从同步延迟等风险。
2. **表级锁** ：操作时锁住整张表，锁定粒度大，锁冲突概率高，并发度低。主要分为表共享读锁和表独占写锁。
3. **元数据锁（MDL）** ：当对表进行增删改查时加 MDL 读锁，共享；当对表结构进行变更操作时加 MDL 写锁，排他。其作是维护表结构的数据一致性，避免 DML 与 DDL 冲突。
4. **意向锁** ：包括意向共享锁（IS）和意向排他锁（IX），由系统自动添加，用于声明事务对表中某些行加锁的意向，减少锁检查，与表锁的兼容性规则如下表。

|当前锁 \ 请求锁|IS|IX|S|X|
|---|---|---|---|---|
|IS|✔️|✔️|✔️|❌|
|IX|✔️|❌|❌|❌|
|S|✔️|❌|✔️|❌|
|X|❌|❌|❌|❌|

5. **行级锁** ：操作时只锁住对应的行数据，锁定粒度最小，锁冲突概率低，并发度高。主要分为以下三类：
    * **记录锁（Record Lock）** ：锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete。在 RC、RR 隔级别下都支持。
    * **间隙锁（GapLock）** ：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在 RR 隔离级别下支持。
    * **临键锁（Next-KevLock）** ：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙 Gap。在 RR 隔离级别下持。

### 加锁规则

**Innodb的所有当前读操 & 任何更新操作都会对该行加上行级锁。**

1. **行锁的加锁条件** ：

|SQL|行锁类型|说明|
|---|---|---|
|INSERT …|排他锁|自动加锁|
|UPDATE …|排他锁|自动加锁|
|DELETE …|排他锁|自动加锁|
|SELECT（正常）|不加任何锁||
|SELECT … LOCK IN SHARE MODE|共享锁|需要手动在 SELECT 之后加 LOCK IN SHARE MODE|
|SELECT … FOR UPDATE|排他锁|需要手动在 SELECT 之后加 FOR UPDATE|

2. **间隙锁与临键锁的加锁规则** ：默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，使用 next-key 锁行搜索和索引扫描，以防止幻读。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。
3. **意向锁的加锁规则** ：所有申请行锁的操作都需要先申请到相同占有模式下的表级意向锁。如针对一行记录加 X Lock，需要先申请得到该行所在的表级 IX Lock。
4. **插入意向锁的加锁规则** ：在插入记录前，需要前置检查其所属的范围是否存在间隙锁，判断方式是通过查看范围右边界的条记录中是否存在间隙锁标识。插入意向锁配合间隙锁使用，避免因插入行为导致幻读。

## MVCC

InnoDB 的 MVCC（多版本并发控制）是 MySQL 实现高并发事务处理的一种机制。通过 MVCC，InnoDB 可以在高并发环境下支持事务隔离，并提供非阻塞的读操作，从而避免锁定所有读操作带来的性能瓶颈。以下是 InnoDB 实现 MVCC 的详细解析：

### 核心原理

InnoDB 的 MVCC 通过以下组件实现：

1. **隐藏字段**：每行记录包含两个隐藏字段：
   - `DB_TRX_ID`：记录最后一次修改该行的事务 ID。
   - `DB_ROLL_PTR`：指向该行历史版本的回滚指针（通过 Undo Log 构建版本链）。

2. **Undo Log（回滚日志）**：
   - 用于存储数据修改前的历史版本。
   - 通过 `DB_ROLL_PTR` 构建版本链，支持事务回滚和一致性读。

3. **ReadView（读视图）**：
   - 事务在启动时生成一个 ReadView，用于判断哪些版本的数据对当前事务可见。
   - ReadView 包含以下关键信息：
     - `m_ids`：当前活跃（未提交）的事务 ID 集合。
     - `min_trx_id`：活跃事务中的最小事务 ID。
     - `max_trx_id`：下一个将要分配的事务 ID。
     - `creator_trx_id`：创建该 ReadView 的事务 ID。

### 工作流程

1. **数据可见性判断**：
   - 当事务执行查询时，InnoDB 会遍历数据的版本链，通过 ReadView 判断每个版本是否对当前事务可见。
   - 如果数据的 `DB_TRX_ID` 满足以下条件之一，则可见：
     - `DB_TRX_ID < min_trx_id`：该版本在 ReadView 创建前已提交。
     - `DB_TRX_ID = creator_trx_id`：该版本是当前事务自身修改的。
   - 如果 `DB_TRX_ID` 在 `m_ids` 中，说明该版本由未提交的事务修改，不可见。
   - 否则，继续检查更早的版本（通过 `DB_ROLL_PTR` 回溯）。

2. **不同隔离级别的实现**：
   - **读已提交（Read Committed）**：每次查询生成新的 ReadView，总能读取已提交的最新数据。
   - **可重复读（Repeatable Read）**：事务第一次查询时生成 ReadView，后续查询复用该 ReadView，确保多次读取结果一致。

### 解决并发问题

| 并发问题 | MVCC 的解决方案 |
|----------|-----------------|
| **脏读** | 通过 ReadView 过滤未提交的事务修改。 |
| **不可重复读** | 在可重复读级别下，复用同一 ReadView。 |
| **幻读** | 通过间隙锁（Gap Lock）阻止新数据插入。 |

### 关键优势

1. **读不阻塞写，写不阻塞读**：读操作基于历史版本，无需加锁；写操作修改最新版本，互不冲突。
2. **减少锁竞争**：通过版本链避免共享锁（S Lock）的使用，提升并发性能。
3. **支持快照读**：在 `SELECT` 语句默认使用一致性读（Consistent Read），无需锁资源。

### 局限性

1. **空间开销**：历史版本存储在 Undo Log 中，长期未提交的事务可能导致 Undo Log 膨胀。
2. **写操作仍需加锁**：写操作（如 `UPDATE`、`DELETE`）需要对记录加排他锁（X Lock）。
3. **幻读的边界情况**：在可重复读隔离级别下，若事务中存在当前读（如 `SELECT ... FOR UPDATE`），仍可能触发幻读，需配合间隙锁解决。

### 示例场景

假设事务 A（事务 ID=100）修改一行数据，生成新版本并写入 Undo Log。事务 B（事务 ID=101）启动，生成 ReadView，此时 `m_ids = [100, 101]`。事务 B 查询该行数据时：
- 检查最新版本的 `DB_TRX_ID=100`（属于活跃事务），不可见。
- 通过 `DB_ROLL_PTR` 找到上一个版本，若 `DB_TRX_ID < min_trx_id`，则可见。

### 总结

InnoDB 的 MVCC 通过版本链和 ReadView 机制，在保证事务隔离性的同时大幅提升并发性能。理解 MVCC 的工作原理有助于优化事务设计、合理选择隔离级别以及排查一致性读与锁冲突引发的问题。