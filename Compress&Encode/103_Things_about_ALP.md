# ALP(Adaptive Lossless Floating-Point Compression)

### 浮点数精度丢失问题

在将**IEEE 754双精度浮点数（doubles）转换为整数以实现压缩时**，核心存在两类精度丢失问题，具体表现及根源如下：

#### 1. 浮点数转整数解码阶段的精度偏差

- **问题表现**：通过传统十进制编码（如PDE的`P_enc`/`P_dec`流程）转换时，解码结果无法还原原始浮点数的精确位模式。  
  示例：对于浮点数`n=8.0605`，按`P_enc=round(n×10⁴)`编码得到整数`d=80605`，再通过`P_dec=d×10⁻⁴`解码时，结果为`8.0605000000000011084`，而非原始IEEE 754双精度表示的`8.06049999999999933209`，导致无损压缩失败。
- **根本原因**：  
  双精度浮点数无法精确表示`10⁻ᵉ`（e为小数点右移位数）。例如`10⁻⁴`（即0.0001）的实际双精度存储值为`0.000100000000000000002082`，该误差在`P_dec`的乘法步骤中被放大，最终导致解码结果偏离原始值。  
  注：`P_enc`阶段（`n×10ᵉ`）无精度损失，因为`10ᵉ`在`e≤21`时可被双精度精确表示。

#### 2. 整数表示的52位限制导致的舍入误差
- **问题表现**：当浮点数的“数量级+可见 decimal 精度”≥16时，`P_enc`计算出的整数会超出双精度的精确整数表示范围，触发自动舍入，导致编码不可逆。  
  示例：POI-lat、POI-lon数据集（平均decimal精度15.7-15.9），使用`e=14`编码时，`n×10¹⁴`的结果常超过`2⁵³`（双精度可精确表示的最大整数范围为`-2⁵³~2⁵³`），自动舍入后无法通过`P_dec`还原原始值，成功编码率仅70.5%-76.4%。
- **根本原因**：  
  双精度浮点数的尾数（fraction）仅52位，仅能精确表示`-2⁵³~2⁵³`之间的整数；超出该范围后，整数需按“2的幂次步进”存储（如`2⁵³~2⁵⁴`仅存偶数、`2⁵⁴~2⁵⁵`仅存4的倍数），`P_enc`的乘法结果若超出此范围，会被强制舍入，丢失原始精度。


#### 对应的解决方案
针对上述两类精度丢失问题，文献[1] 2.5节及后续设计提出4类核心解法，兼顾精度保留与压缩效率：

##### 1. 采用高指数e提升解码精度
- **核心思路**：使用更高的指数`e`（如14、16），使`10⁻ᵉ`的双精度表示更接近真实值，减少`P_dec`的误差。  
- **效果**：  
  - 高指数`e`（如14）可使`10⁻¹⁴`的双精度表示为`1.00000000000000007771E-15`，误差极小，解码结果更接近原始浮点数；  
  - 全数据集平均成功编码率从“按可见精度选e”的82.5%提升至95%，部分数据集（如SD-bench、Stocks-UK）达99.9%；  
  - 进一步优化为“按向量选e”（每个1024值向量用1个e），成功编码率再提升至97.2%。

##### 2. 引入因子f裁剪尾部零，规避大整数存储
- **核心思路**：在`P_enc`基础上增加因子`f`（`f≤e`），通过`ALP_enc=round(n×10ᵉ×10⁻ᶠ)`裁剪整数`d`的尾部零，减少整数长度，同时避免新误差。  
- **原理与示例**：  
  对`n=8.0605`（原始双精度`8.06049999999999933209`），取`e=14`、`f=10`：  
  `ALP_enc=round(8.06049999999999933209×10¹⁴×10⁻¹⁰)=round(80604.9999999985448)=80605`，解码时`ALP_dec=80605×10¹⁰×10⁻¹⁴`，可精确还原原始值；  
  尾部零裁剪不引入新误差，因`10⁻ᶠ`的误差对整数`d`的round结果影响可忽略。

##### 3. 向量级自适应优化，减少参数开销与搜索成本
- **核心思路**：放弃“逐值选e”（如PDE），改为“按向量选e和f”，利用向量内decimal精度、数量级方差小的特性，缩减搜索空间。  
- **具体措施**：  
  - 搜索空间从253种（`0≤e≤21`、`f≤e`）缩减至5种以内，多数数据集（如Basel-wind、City-Temp）仅需1种最优`(e,f)`组合；  
  - 向量级参数存储（e、f、位宽仅存1次/1024值），避免逐值存储e的空间开销，同时减少CPU分支预测错误（无逐值if-else）。

##### 4. 针对高精度数据的`ALP_rd` fallback方案
- **核心思路**：对“数量级+decimal精度≥16”的高压缩难度数据（如POI-lat），放弃“整数转换”，转而压缩浮点数的前导位（sign+exponent+尾数高位），保留尾随位以保精度。  
- **实现**：  
  - 分割浮点数为前导位（低方差，用倾斜字典+位打包压缩）和尾随位（高随机，直接位打包）；  
  - 字典大小限制为`2³`（8个值），异常值（非字典值）用16位存储位置和值，确保精度无损，同时压缩比优于Gorilla、Elf等方案。

### ALP 核心原理
ALP（Adaptive Lossless floating-Point Compression）是针对 IEEE 754 双精度浮点数的自适应无损压缩算法，核心原理围绕 **“向量化执行”“双策略编码”“低开销自适应”** 三大设计，兼顾压缩比与编解码速度：

核心设计理念

- **向量化执行**：以 1024 个浮点数为一个向量块处理，利用现代 CPU 的 SIMD 架构，通过 scalar 代码自动向量化，减少循环开销与分支预测错误。
- **双策略自适应编码**：
  - 主策略（十进制编码）：若浮点数源自十进制（文档中 28/30 数据集符合），通过增强版 PseudoDecimals 编码为整数，利用向量内精度/数量级一致性优化压缩。
  -  fallback 策略（`ALP_rd`）：若浮点数为高精度“真实浮点数”（如 POI 坐标，精度≥16），分割为前导位（符号+指数+尾数高位，低方差）和尾随位（高随机），分别压缩后拼接。
- **低开销参数优化**：通过两级采样机制快速找到最优编码参数（指数 e、尾部零裁剪因子 f、分割位置 p），避免暴力搜索；参数按向量/行组存储（而非逐值）， amortize 存储开销。
- **关键优化**：
  - 快速舍入：用 `sweet_n=2^51+2^52` 替代 SIMD 不支持的 round 操作，通过“加减偏移+强制类型转换”实现无精度损失的快速舍入。
  - 异常处理：避免逐值判断，用辅助值填充异常位置，单独存储异常值与位置，保证向量执行的规整性。
  - FFOR 融合：将整数编码（Frame-Of-Reference）与位打包融合为单内核，减少 SIMD 存储/加载指令，提升速度。

核心模块

| 模块                | 作用                                  | 设计细节                                                                 |
|---------------------|---------------------------------------|--------------------------------------------------------------------------|
| 两级采样（Adaptive Sampling） | 确定最优编码参数（e/f 或 p/DICT） | 行组采样（8 向量×32 值）筛选 top-k 组合，向量采样（32 值）快速匹配最优解，搜索空间缩减至 5 种以内。 |
| 十进制编码（ALP_enc/ALP_dec） | 浮点数↔整数无损转换 | 高指数 e 保证解码精度，因子 f 裁剪尾部零缩小整数长度，避免大整数存储开销。 |
| `ALP_rd` 前导位压缩 | 高精度浮点数压缩 | 分割位置 p 保证前导位低方差，倾斜字典压缩前导位，位打包存储尾随位，异常值单独处理。 |
| FFOR 编码           | 整数进一步压缩 | 减去向量内最小值，再位打包，利用向量内整数局部性减少存储位数。             |
| 异常处理            | 保证无损性                            | 异常值（编码失败的浮点数）存储原始值+16 位位置，辅助值填充编码向量，不影响位宽。 |

---

#### ALP 核心步骤（压缩+解压）

##### 1. 压缩步骤（主流程+`ALP_rd`  fallback）

- 步骤 1：数据预处理与向量划分
  - 输入：64 位双精度浮点数数组（如数据库列、时间序列数据）。
  - 划分：按 1024 个值为单位划分为向量，100 个向量组成 1 个行组（模拟 OLAP 引擎行组大小）。
- 步骤 2：两级采样确定编码策略与参数
  - 第一级采样（行组级）：
    - 从行组中采样 8 个向量，每个向量采样 32 个值，遍历 253 种 `(e,f)` 组合，筛选出压缩效果最优的 k=5 种组合（优先高 e/f）。
    - 若采样结果显示“编码异常率高（>阈值）+ 整数>2^48”，判定为“真实浮点数”，切换至 `ALP_rd` 策略，采样确定分割位置 p 和字典 DICT（大小≤8）。
  - 第二级采样（向量级）：
    - 对每个向量采样 32 个值，从 top-k 组合中选择最优 `(e,f)`（贪心早停：连续 2 种组合性能下降则停止）；若 k=1 则跳过该步骤。
- 步骤 3：执行编码（主策略/`ALP_rd`）
  - 主策略（十进制编码）：
    1. 按 `ALP_enc=round(n × 10^e × 10^(-f))` 将向量内浮点数转换为 int64 整数。
    2. 验证解码：按 `ALP_dec=d × 10^f × 10^(-e)` 还原浮点数，对比原始值，标记异常位置与异常值。
    3. 异常填充：用第一个成功编码的整数 `first_encoded` 填充异常位置，保证向量规整性。
  - `ALP_rd` 策略（前导位压缩）：
    1. 按位置 p 分割每个浮点数：左部（前导位，64-p 位）、右部（尾随位，p 位）。
    2. 左部压缩：用倾斜字典编码（异常值存 16 位）+ 位打包；右部直接位打包。
- 步骤 4：FFOR 整数压缩
  - 对主策略的编码整数向量，执行 FFOR 压缩：减去向量内最小值，再按最小必要位数打包，进一步缩减存储。
- 步骤 5：元数据与数据存储
  - 存储元数据：向量级（e、f、位宽）、行组级（p、DICT）、异常信息（异常值数组+位置数组）。
  - 存储压缩数据：FFOR 压缩后的整数向量 / `ALP_rd` 的左右部压缩数据。

```cpp
// 1. 预定义10的负幂数组：i_F10[f] = 10^(-f)，用于裁剪尾部零（f为裁剪因子）
double i_F10 = {1.0, 0.1, 0.01, 0.001, ...};
// 2. 预定义10的正幂数组：F10[e] = 10^(e)，用于将浮点数转换为整数（e为指数）
double F10 = {1.0, 10.0, 100.0, 1000.0, ...};
// 3. 自适应采样：对输入向量执行两级采样，确定最优编码参数（e=指数，f=尾部零裁剪因子）
//    BEST_COMBINATIONS：预设候选组合池（由行组级采样筛选的Top5组合）
int e, f = ALP::ADAPTIVE_SAMPLING(input_vec, BEST_COMBINATIONS);
// 4. 编码核心逻辑：通过Lambda表达式封装向量级编码流程，返回3个结果：
//    encoded_vec：编码后的整数向量；exc_vec：异常值向量；exc_pos_vec：异常值在原向量中的位置向量
encoded_vec, exc_vec, exc_pos_vec = ALP::ENCODE([]() { 
    // 5. 遍历向量中所有浮点数（VECTOR_SIZE=1024，固定向量大小）
    for (i = 0; i < VECTOR_SIZE; ++i){ 
        // 6. 取出当前待编码的双精度浮点数n
        double n = input_vec[i];
        // 7. ALP核心编码（ALP_enc）：
        //    ① n×10^e：将浮点数小数点右移e位，转为大数
        //    ② ×10^(-f)：裁剪尾部f个零，缩小整数规模
        //    ③ fast_double_round：SIMD友好的快速舍入（无round指令依赖）
        //    ④ 结果转为int64：存储编码后的整数d（支持大整数，避免32位限制）
        int64 d = fast_double_round(n * F10[e] * i_F10[f]); // 𝐴𝐿𝑃𝑒𝑛𝑐
        // 8. 将编码后的整数d存入编码向量
        encoded_vec[i] = d;
        // 9. 即时解码验证（ALP_dec）：反向执行编码步骤，验证是否无损
        //    用于后续检测异常值，确保压缩无损性
        decoded_vec[i] = d * F10[f] * i_F10[e]; // 𝐴𝐿𝑃𝑑𝑒𝑐
    }
    // 10. 初始化异常计数器：统计当前向量中编码失败的数值个数
    int exc_count = 0;
    // 11. 遍历向量，检测异常值（解码结果≠原始值的为异常）
    for (i = 0; i < VECTOR_SIZE; ++i) { 
        // 12. 谓词比较：判断解码值与原始值是否一致（无if分支，适配向量化）
        //    neq=true→异常，neq=false→正常
        bool neq = (decoded_vec[i] != input_vec[i]);
        // 13. 累计异常数：布尔值自动转为0/1，避免分支判断（SIMD友好）
        exc_count += neq; 
        // 14. 记录异常位置：仅当neq=true时，exc_count递增，有效存储异常索引i
        exc_pos_vec[exc_count] = i;
    }
    // 15. 查找第一个有效编码值：取向量中第一个编码成功的整数d（用于填充异常位置）
    //    目的：保证encoded_vec规整性，不破坏后续FFOR压缩的向量结构
    int64 first_encoded = FIND_FIRST_ENCODED(exc_pos_vec); 
    // 16. 处理异常值：遍历所有异常，填充+存储原始值
    for (i = 0; i < exc_count; ++i){ 
        // 17. 填充异常位置：用first_encoded替换异常值对应的编码整数
        //    避免向量中出现"空洞"，确保FFOR压缩可正常执行
        encoded_vec[exc_pos_vec[i]] = first_encoded;
        // 18. 存储原始异常值：单独存入exc_vec，解压时用于修补，保证无损
        exc_vec[exc_pos_vec[i]] = input_vec[i];
    }
}); 
// 19. FFOR压缩：对规整后的整数向量执行融合帧参考压缩
//    步骤：① 减向量最小值（归一化）；② 位打包（按最小必要位数存储）
FFOR(encoded_vec);
```

##### 2. 解压步骤

- 步骤 1：读取元数据与初始化
  - 读取向量/行组元数据（e、f、p、DICT、位宽），读取异常信息（异常值+位置）。
- 步骤 2：FFOR/位打包解压
  - 主策略：对压缩整数向量执行 UNFFOR 解压（加回最小值），恢复 int64 整数向量。
  - `ALP_rd` 策略：对位打包的左部执行字典解压+异常修补，右部直接位解包。
- 步骤 3：解码（整数→浮点数/前导位拼接）
  - 主策略：按 `ALP_dec=d × 10^f × 10^(-e)` 将整数还原为浮点数。
  - `ALP_rd` 策略：将解压后的左部（前导位）左移 p 位，与右部（尾随位）通过 OR 操作拼接，还原浮点数。
- 步骤 4：异常修补
  - 按异常位置数组，将异常值替换回解码向量中，得到原始浮点数向量。

```cpp
// 1. 读取向量头部元数据：从压缩向量的头部提取编码时使用的核心参数
//    e：编码时的指数（用于将整数还原为浮点数的小数点移位）
//    f：编码时的尾部零裁剪因子（反向补偿裁剪的零）
//    元数据仅存储1次/向量，开销可忽略，对应压缩时的"向量级参数存储"设计
int e, f = ALP::READ_VECTOR_HEADER(input_vec);

// 2. 执行UNFFOR操作：反向执行压缩时的FFOR（融合帧参考压缩）
//    核心逻辑：① 按编码时的位宽解包；② 加回向量内整数的最小值（还原归一化前的整数）
//    输出：还原后的int64整数向量（与压缩时ALP_enc生成的encoded_vec一致）
int64_vec = UNFFOR(input_vec);

// 3. 解码核心逻辑：通过Lambda表达式封装向量级解码流程，输入为还原后的整数向量
//    输出：最终解码后的双精度浮点数向量decoded_vec
decoded_vec = ALP::DECODE([](int64_vec) {
    // 4. 遍历向量中所有整数（VECTOR_SIZE=1024，与压缩时向量大小一致）
    for (i = 0; i < VECTOR_SIZE; ++i){
        // 5. 异常值修补：根据压缩时存储的异常信息，还原异常位置的原始浮点数
        //    exc_vec：压缩时单独存储的异常值向量（未编码的原始浮点数）
        //    exc_pos_vec：异常值在原始向量中的位置索引
        //    作用：将编码时填充的first_encoded替换为原始异常值，保证无损性
        ALP::PATCH(decoded_vec, exc_vec, exc_pos_vec);
        
        // 6. ALP核心解码（ALP_dec）：反向执行压缩时的ALP_enc，还原原始浮点数
        //    ① int64_vec[i]：当前待解码的整数d
        //    ② ×F10[f]：补偿压缩时裁剪的f个尾部零（d×10^f）
        //    ③ ×i_F10[e]：将小数点左移e位（×10^-e），还原浮点数数量级
        //    最终结果与压缩前的原始浮点数bitwise一致，无精度损失
        decoded_vec[i] = int64_vec[i] * F10[f] * i_F10[e] 
    }
}); // 标注：该步骤对应ALP的核心解码公式𝐴𝐿𝑃𝑑𝑒𝑐
```

##### 3. ALPrd

`ALP_rd`（ALP for Real Doubles）是 ALP 算法的 **自适应 fallback 方案**，专门处理主策略（“浮点数→整数”编码）无法高效压缩的“真实浮点数”——即那些不源自十进制、精度极高、难以无损转换为整数的浮点数（如 POI 坐标、高精度科学测量数据）。

`ALP_rd` 的设计依据如下：

- 真实浮点数的 **前导位（符号+指数+尾数高位）方差小**：即使是高精度数据（如 POI 坐标），其 IEEE 754 位模式的前导部分（64-p 位）仍存在规律性，可通过轻量级压缩（字典编码）减小存储；
- 尾随位（尾数低位）高随机：无明显规律，直接位打包存储即可，无需额外压缩（避免压缩开销大于收益）；
- 行组级决策更高效：文档发现所有数据集的十进制精度偏差不超过 3 位，向量级切换策略会增加元数据开销，行组级决策（100个向量共享1组参数）更划算。

当第一级采样检测到行组（100个向量）满足以下条件时，自动切换为 `ALP_rd`：

- 主策略编码异常率过高（大量浮点数无法通过 `ALP_enc/ALP_dec` 无损转换）；
- 编码后整数超过 \(2^{48}\)（存储开销接近原始浮点数，无压缩意义）。

| 概念                | 定义与作用                                                                 |
|---------------------|----------------------------------------------------------------------------|
| 分割位置 p          | 最小 p≥48（保证前导位足够覆盖低方差部分），通过行组级采样确定，使左部方差最小 |
| 倾斜字典（Skewed Dictionary） | 支持异常的字典编码，字典大小 \(2^b\)（b≤3，即1/2/4/8个值），容忍不在字典中的异常值 |
| 异常值（左部）      | 未匹配字典的前导位值，用16位存储值+16位存储位置，开销低且不影响主压缩流程     |
| 元数据              | 行组级存储 p（8位，可忽略）和字典（16位×字典大小），开销 amortize 到整个行组 |

编码步骤（Encoding）

- 步骤 1：行组级自适应采样（确定 p 和字典）
  - 从行组中采样 m×n 个值（复用主策略的采样参数 m=8、n=32），遍历可能的 p（≥48），选择使左部方差最小的最小 p；
  - 统计采样左部的高频值，构建候选字典：从 size=1（2^0）开始尝试，选择最小 b（b≤3）使字典异常率（未匹配值占比）≤10%；若均不满足，使用 b=3（字典大小8）；
  - 输出采样结果：分割位置 p、最优倾斜字典 DICT。
- 步骤 2：分割浮点数为左右两部，遍历行组内每个向量的每个浮点数 \(n\)：
  - 将浮点数按 IEEE 754 位模式转为 uint64_t（无精度损失）；
  - 左部（left_vec[i]）：右移 p 位，取高 64-p 位，转为 int16_t（因 p≥48，64-p≤16，足够存储）；
  - 右部（right_vec[i]）：与 \((1ULL << p) - 1\) 按位与，取低 p 位，保留原始随机部分。
- 步骤 3：分别压缩左右两部
  - 左部压缩：执行 `SKEWDICT_BITPACK` → ① 用倾斜字典编码左部，异常值存入 exc_vec_left、位置存入 exc_pos_left；② 对字典编码后的代码（b 位/值）进行位打包；
  - 右部压缩：执行 `BITPACK` → 按 p 位对右部进行位打包（每个值占用 p 位，无浪费）。
- 步骤 4：存储结果
  - 元数据：行组头部存储 p 和字典 DICT；
  - 压缩数据：左部压缩结果 + 右部压缩结果；
  - 异常信息：左部的 exc_vec_left（16位/值）和 exc_pos_left（16位/位置）。

解码步骤（Decoding）

- 步骤 1：从行组头部读取分割位置 p 和倾斜字典 DICT，读取左部异常信息（exc_vec_left、exc_pos_left）。
- 步骤 2：解压缩左右两部
  - 左部解压：① 对位打包的左部代码执行位解包；② 用 `BITUNPACK_DECODEDICT` 执行字典解码，结合 exc_vec_left 和 exc_pos_left 修补异常，还原左部 int16_t 向量；
  - 右部解压：对位打包的右部执行 `BITUNPACK`，还原右部 uint64_t 向量（p 位）。
- 步骤 3：拼接左右两部（GLUE 操作）遍历每个值，通过向量化的移位和 OR 操作融合：
  - 左部左移 p 位：将前导位恢复到原始高位位置；
  - 与右部按位 OR：拼接尾数低位，还原完整的 uint64_t 位模式；
  - 转为 double：将 uint64_t 位模式强制转换为 double（无精度损失）。
- 步骤 4：最终修补。若存在右部异常（文档未明确，但复用主策略逻辑），按位置替换为原始值，确保无损。

#### 自适应采样

ALP的自适应采样是为了解决“高效寻找最优编码参数（指数e、尾部零裁剪因子f）”的问题，核心思想是**利用数据共性缩减搜索空间**，避免逐值/逐向量暴力搜索（253种(e,f)组合）的高开销，同时保证压缩效果最优。

设计依据

- 向量内共性强：25/30个数据集的向量（1024值）内，十进制精度和数量级方差极小，同一数据集的向量最优(e,f)组合高度集中（图3显示多数数据集仅需5种以内，部分仅1种）。
- 暴力搜索开销大：直接遍历253种组合（0≤e≤21、f≤e）会导致压缩速度骤降，而两级采样可将搜索空间缩减至5种以内，采样开销仅占压缩总时间的6%。

从而找到“使编码后整数最小、异常值最少”的(e,f)组合----即最小化“异常值存储大小 + 位打包整数大小”之和，同时优先选择高e和高f（高e提升无损编码成功率，高f裁剪更多尾部零）。


> 行组（row-group）：100个连续向量（每个向量1024值），模拟OLAP引擎的行组大小， amortize 采样开销。
>
> 采样参数：m=8（行组中采样的向量数）、n=32（每个采样向量中采样的值数）、k=5（保留的最优组合数）、s=32（向量级采样的值数）、w=100（行组内向量数）。


采样分为**第一级（行组级）** 和**第二级（向量级）** ，逐级缩减搜索空间，最终确定每个向量的最优(e,f)组合。

- 第一步：第一级采样（行组级，全局筛选）：从整个行组中筛选出“出现频率最高、压缩效果最优”的Top k=5种(e,f)组合，作为后续向量级采样的候选池。
  1. **数据采样**：从行组（100个向量）中选取8个（m=8）等距向量，每个向量选取32个（n=32）等距值，共采集8×32=256个值（覆盖行组数据分布）。
  2. **全空间搜索**：对每个采样向量，遍历所有253种(e,f)组合（0≤e≤21、f≤e），计算每种组合的“压缩效果评分”——评分=异常值存储大小（未编码成功的值占用空间）+ 位打包整数大小（编码后整数所需存储位数）。对每个采样向量，选出评分最低（压缩效果最优）的1种(e,f)组合。
  3. **筛选Top k'组合**：
      - 收集8个采样向量的8种候选组合，统计每种组合的出现次数。
      - 保留出现次数最多的k=5种组合（若总组合数<5，则保留全部，记为k'≤5）。
      - 优先级规则：若两种组合出现次数相同，优先选择e更大的组合；e相同则优先f更大的组合（高e提升无损成功率，高f减少整数长度）。
  4. **输出候选池**：生成包含k'种组合的候选池，供第二级采样使用。
- 第二步：第二级采样（向量级，局部最优）：对行组内每个向量，从第一级筛选的k'种组合中，快速找到适配该向量的最优(e,f)组合。
  1. **条件判断**：
      - 若第一级筛选后k'=1（所有采样向量的最优组合相同，如City-Temp、SD-bench数据集），则跳过该步骤，直接使用这1种组合编码整个行组的向量（无额外开销）。
      - 若k'>1，则执行向量级采样。
  2. **向量内采样**：
      - 对当前向量，选取32个（s=32）等距值，覆盖向量内数据分布。
  3. **候选组合评估**：
      - 遍历第一级生成的k'种组合，对每个组合，计算32个采样值的“压缩效果评分”（同第一步的评分规则）。
  4. **贪心早期退出**：
      - 按出现频率从高到低遍历组合，若连续两个组合（k'_i+1、k'_i+2）的评分均不优于当前最优组合（k'_i），则立即停止搜索，选择当前最优组合编码整个向量。
      - 例：若遍历到第3种组合时，其评分不如第1种，且第4种也不如第1种，则直接选择第1种组合，无需遍历剩余组合。
- 第三步：参数确定与编码
  - 每个向量最终确定1种(e,f)组合，用于后续ALP_enc编码。
  - 采样结果验证：文档实验表明，该采样找到的组合与“全空间暴力搜索”的最优组合相比，压缩比损失<1%，但采样开销仅占压缩总时间的6%。
